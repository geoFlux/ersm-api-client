/**
 * My API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as querystring from "querystring";
import * as url from "url";

import * as isomorphicFetch from "isomorphic-fetch";
import * as assign from "core-js/library/fn/object/assign";

interface Dictionary<T> { [index: string]: T; }
export interface FetchAPI { (url: string, init?: any): Promise<any>; }

const BASE_PATH = "https://localhost/".replace(/\/+$/, "");

export interface FetchArgs {
    url: string;
    options: any;
}

export class BaseAPI {
    basePath: string;
    fetch: FetchAPI;

    constructor(fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) {
        this.basePath = basePath;
        this.fetch = fetch;
    }
};

export interface ActionResultsCategoryResult {
    "upsert"?: Array<InlineResponse200PdfCategoriesUpsert>;
    "delete"?: Array<string>;
}

export interface ActionResultsContactCategoryMapResult {
    "upsert"?: Array<InlineResponse200ContactCategoryToSubCategoryMapUpsert>;
    "delete"?: Array<string>;
}

export interface ActionResultsContactCategoryResult {
    "upsert"?: Array<InlineResponse200ContactSubCategoriesUpsert>;
    "delete"?: Array<string>;
}

export interface ActionResultsContactPeopleMapResult {
    "upsert"?: Array<InlineResponse200ContactPeopleMapUpsert>;
    "delete"?: Array<string>;
}

export interface ActionResultsContactPeopleResultNoPicture {
    "upsert"?: Array<InlineResponse200ContactPeopleUpsert>;
    "delete"?: Array<string>;
}

export interface ActionResultsContactTypesResult {
    "upsert"?: Array<InlineResponse200PdfCategoriesUpsert>;
    "delete"?: Array<string>;
}

export interface ActionResultsGuid {
    "upsert"?: Array<string>;
    "delete"?: Array<string>;
}

export interface ActionResultsLpcResultNoPhotoOrIcon {
    "upsert"?: Array<InlineResponse200LpcUpsert>;
    "delete"?: Array<string>;
}

export interface ActionResultsPdfMetaDataResult {
    "upsert"?: Array<InlineResponse200PdfsUpsert>;
    "delete"?: Array<string>;
}

export interface AppDataResults {
    "dataVersion"?: string;
    "pdfCategories"?: InlineResponse200PdfCategories;
    "pdfs"?: InlineResponse200Pdfs;
    "contactPeople"?: InlineResponse200ContactPeople;
    "contactCategories"?: InlineResponse200PdfCategories;
    "contactSubCategories"?: InlineResponse200ContactSubCategories;
    "contactCategoryToSubCategoryMap"?: InlineResponse200ContactCategoryToSubCategoryMap;
    "contactPeopleMap"?: InlineResponse200ContactPeopleMap;
    "contactPictures"?: InlineResponse200ContactPictures;
    "lpc"?: InlineResponse200Lpc;
    "lpcPhotos"?: InlineResponse200ContactPictures;
    "lpcIcons"?: InlineResponse200ContactPictures;
}

export interface CategoryResult {
    "id"?: string;
    "label"?: string;
}

export interface ContactCategoryMapResult {
    "id"?: string;
    "categoryId"?: string;
    "subCategoryId"?: string;
}

export interface ContactCategoryResult {
    "id"?: string;
    "label"?: string;
    "orderBy"?: number;
}

export interface ContactPeopleMapResult {
    "id"?: string;
    "categoryMapId"?: string;
    "personId"?: string;
}

export interface ContactPeopleResult {
    "id"?: string;
    "region"?: string;
    "firstName"?: string;
    "lastName"?: string;
    "phone"?: string;
    "cell"?: string;
    "email"?: string;
    "hasPicture"?: boolean;
}

export interface ContactPeopleResultNoPicture {
    "id"?: string;
    "region"?: string;
    "firstName"?: string;
    "lastName"?: string;
    "phone"?: string;
    "cell"?: string;
    "email"?: string;
}

export interface ContactPersonCategoryResult {
    "categoryId"?: string;
    "categoryLabel"?: string;
    "subCategoryId"?: string;
    "subCategoryLabel"?: string;
}

export interface ContactSubCategoryResult {
    "id"?: string;
    "label"?: string;
    "orderBy"?: number;
}

export interface ContactTypesResult {
    "id"?: string;
    "label"?: string;
}

export interface InlineResponse200 {
    "dataVersion"?: string;
    "pdfCategories"?: InlineResponse200PdfCategories;
    "pdfs"?: InlineResponse200Pdfs;
    "contactPeople"?: InlineResponse200ContactPeople;
    "contactCategories"?: InlineResponse200PdfCategories;
    "contactSubCategories"?: InlineResponse200ContactSubCategories;
    "contactCategoryToSubCategoryMap"?: InlineResponse200ContactCategoryToSubCategoryMap;
    "contactPeopleMap"?: InlineResponse200ContactPeopleMap;
    "contactPictures"?: InlineResponse200ContactPictures;
    "lpc"?: InlineResponse200Lpc;
    "lpcPhotos"?: InlineResponse200ContactPictures;
    "lpcIcons"?: InlineResponse200ContactPictures;
}

export interface InlineResponse2001 {
    "id"?: string;
    "region"?: string;
    "firstName"?: string;
    "lastName"?: string;
    "phone"?: string;
    "cell"?: string;
    "email"?: string;
    "hasPicture"?: boolean;
}

export interface InlineResponse2002 {
    "categoryId"?: string;
    "categoryLabel"?: string;
    "subCategoryId"?: string;
    "subCategoryLabel"?: string;
}

export interface InlineResponse2003 {
    "id"?: string;
    "name"?: string;
    "address1"?: string;
    "city1"?: string;
    "state1"?: string;
    "zip1"?: string;
    "address2"?: string;
    "city2"?: string;
    "state2"?: string;
    "zip2"?: string;
    "web"?: string;
    "phone"?: string;
    "fax"?: string;
    "totalElectricCustomers"?: number;
    "residentialCustomers"?: number;
    "ciCustomersLessThan50kw"?: number;
    "ciCustomers51To4999Kw"?: number;
    "ciCustomersGreaterThan5000kw"?: number;
    "totalNaturalGasCustomers"?: number;
    "totalWaterCustomers"?: number;
    "totalWastewaterCustomers"?: number;
    "totalSystemAssets"?: number;
    "taxes"?: number;
    "milesOfLine"?: number;
    "customersPerMile"?: number;
    "avgResidentialUseInKwhPerMonth"?: number;
    "deliveryPoints"?: number;
    "avgLoadFactor"?: number;
    "hasPhoto"?: boolean;
    "hasIcon"?: boolean;
}

export interface InlineResponse200ContactCategoryToSubCategoryMap {
    "upsert"?: Array<InlineResponse200ContactCategoryToSubCategoryMapUpsert>;
    "delete"?: Array<string>;
}

export interface InlineResponse200ContactCategoryToSubCategoryMapUpsert {
    "id"?: string;
    "categoryId"?: string;
    "subCategoryId"?: string;
}

export interface InlineResponse200ContactPeople {
    "upsert"?: Array<InlineResponse200ContactPeopleUpsert>;
    "delete"?: Array<string>;
}

export interface InlineResponse200ContactPeopleMap {
    "upsert"?: Array<InlineResponse200ContactPeopleMapUpsert>;
    "delete"?: Array<string>;
}

export interface InlineResponse200ContactPeopleMapUpsert {
    "id"?: string;
    "categoryMapId"?: string;
    "personId"?: string;
}

export interface InlineResponse200ContactPeopleUpsert {
    "id"?: string;
    "region"?: string;
    "firstName"?: string;
    "lastName"?: string;
    "phone"?: string;
    "cell"?: string;
    "email"?: string;
}

export interface InlineResponse200ContactPictures {
    "upsert"?: Array<string>;
    "delete"?: Array<string>;
}

export interface InlineResponse200ContactSubCategories {
    "upsert"?: Array<InlineResponse200ContactSubCategoriesUpsert>;
    "delete"?: Array<string>;
}

export interface InlineResponse200ContactSubCategoriesUpsert {
    "id"?: string;
    "label"?: string;
    "orderBy"?: number;
}

export interface InlineResponse200Lpc {
    "upsert"?: Array<InlineResponse200LpcUpsert>;
    "delete"?: Array<string>;
}

export interface InlineResponse200LpcUpsert {
    "hasPhoto"?: boolean;
    "hasIcon"?: boolean;
    "id"?: string;
    "name"?: string;
    "address1"?: string;
    "city1"?: string;
    "state1"?: string;
    "zip1"?: string;
    "address2"?: string;
    "city2"?: string;
    "state2"?: string;
    "zip2"?: string;
    "web"?: string;
    "phone"?: string;
    "fax"?: string;
    "totalElectricCustomers"?: number;
    "residentialCustomers"?: number;
    "ciCustomersLessThan50kw"?: number;
    "ciCustomers51To4999Kw"?: number;
    "ciCustomersGreaterThan5000kw"?: number;
    "totalNaturalGasCustomers"?: number;
    "totalWaterCustomers"?: number;
    "totalWastewaterCustomers"?: number;
    "totalSystemAssets"?: number;
    "taxes"?: number;
    "milesOfLine"?: number;
    "customersPerMile"?: number;
    "avgResidentialUseInKwhPerMonth"?: number;
    "deliveryPoints"?: number;
    "avgLoadFactor"?: number;
}

export interface InlineResponse200PdfCategories {
    "upsert"?: Array<InlineResponse200PdfCategoriesUpsert>;
    "delete"?: Array<string>;
}

export interface InlineResponse200PdfCategoriesUpsert {
    "id"?: string;
    "label"?: string;
}

export interface InlineResponse200Pdfs {
    "upsert"?: Array<InlineResponse200PdfsUpsert>;
    "delete"?: Array<string>;
}

export interface InlineResponse200PdfsUpsert {
    "id"?: string;
    "screen"?: string;
    "categoryId"?: string;
    "label"?: string;
    "text"?: string;
}

export interface LpcResult {
    "id"?: string;
    "name"?: string;
    "address1"?: string;
    "city1"?: string;
    "state1"?: string;
    "zip1"?: string;
    "address2"?: string;
    "city2"?: string;
    "state2"?: string;
    "zip2"?: string;
    "web"?: string;
    "phone"?: string;
    "fax"?: string;
    "totalElectricCustomers"?: number;
    "residentialCustomers"?: number;
    "ciCustomersLessThan50kw"?: number;
    "ciCustomers51To4999Kw"?: number;
    "ciCustomersGreaterThan5000kw"?: number;
    "totalNaturalGasCustomers"?: number;
    "totalWaterCustomers"?: number;
    "totalWastewaterCustomers"?: number;
    "totalSystemAssets"?: number;
    "taxes"?: number;
    "milesOfLine"?: number;
    "customersPerMile"?: number;
    "avgResidentialUseInKwhPerMonth"?: number;
    "deliveryPoints"?: number;
    "avgLoadFactor"?: number;
    "hasPhoto"?: boolean;
    "hasIcon"?: boolean;
}

export interface LpcResultNoPhotoOrIcon {
    "hasPhoto"?: boolean;
    "hasIcon"?: boolean;
    "id"?: string;
    "name"?: string;
    "address1"?: string;
    "city1"?: string;
    "state1"?: string;
    "zip1"?: string;
    "address2"?: string;
    "city2"?: string;
    "state2"?: string;
    "zip2"?: string;
    "web"?: string;
    "phone"?: string;
    "fax"?: string;
    "totalElectricCustomers"?: number;
    "residentialCustomers"?: number;
    "ciCustomersLessThan50kw"?: number;
    "ciCustomers51To4999Kw"?: number;
    "ciCustomersGreaterThan5000kw"?: number;
    "totalNaturalGasCustomers"?: number;
    "totalWaterCustomers"?: number;
    "totalWastewaterCustomers"?: number;
    "totalSystemAssets"?: number;
    "taxes"?: number;
    "milesOfLine"?: number;
    "customersPerMile"?: number;
    "avgResidentialUseInKwhPerMonth"?: number;
    "deliveryPoints"?: number;
    "avgLoadFactor"?: number;
}

export interface PdfMetaDataResult {
    "id"?: string;
    "screen"?: string;
    "categoryId"?: string;
    "label"?: string;
    "text"?: string;
}



/**
 * AppDataApi - fetch parameter creator
 */
export const AppDataApiFetchParamCreator = {
    /** 
     * @param dataVersion 
     * @param forceLpcData 
     */
    apiAppDataGet(params: {  "dataVersion"?: string; "forceLpcData"?: boolean; }, options?: any): FetchArgs {
        const baseUrl = `/api/AppData`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "dataVersion": params["dataVersion"],
            "forceLpcData": params["forceLpcData"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AppDataApi - functional programming interface
 */
export const AppDataApiFp = {
    /** 
     * @param dataVersion 
     * @param forceLpcData 
     */
    apiAppDataGet(params: { "dataVersion"?: string; "forceLpcData"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = AppDataApiFetchParamCreator.apiAppDataGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AppDataApi - object-oriented interface
 */
export class AppDataApi extends BaseAPI {
    /** 
     * @param dataVersion 
     * @param forceLpcData 
     */
    apiAppDataGet(params: {  "dataVersion"?: string; "forceLpcData"?: boolean; }, options?: any) {
        return AppDataApiFp.apiAppDataGet(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AppDataApi - factory interface
 */
export const AppDataApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param dataVersion 
         * @param forceLpcData 
         */
        apiAppDataGet(params: {  "dataVersion"?: string; "forceLpcData"?: boolean; }, options?: any) {
            return AppDataApiFp.apiAppDataGet(params, options)(fetch, basePath);
        },
    };
};


/**
 * ContactCategoriesApi - fetch parameter creator
 */
export const ContactCategoriesApiFetchParamCreator = {
    /** 
     * *Auth Required
     * @param categoryId 
     */
    apiContactsCategoriesByCategoryIdDelete(params: {  "categoryId": string; }, options?: any): FetchArgs {
        // verify required parameter "categoryId" is set
        if (params["categoryId"] == null) {
            throw new Error("Missing required parameter categoryId when calling apiContactsCategoriesByCategoryIdDelete");
        }
        const baseUrl = `/api/Contacts/Categories/{categoryId}`
            .replace(`{${"categoryId"}}`, `${ params["categoryId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param categoryId 
     */
    apiContactsCategoriesByCategoryIdPeopleGet(params: {  "categoryId": string; }, options?: any): FetchArgs {
        // verify required parameter "categoryId" is set
        if (params["categoryId"] == null) {
            throw new Error("Missing required parameter categoryId when calling apiContactsCategoriesByCategoryIdPeopleGet");
        }
        const baseUrl = `/api/Contacts/Categories/{categoryId}/People`
            .replace(`{${"categoryId"}}`, `${ params["categoryId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * *Auth Required
     * @param categoryId 
     * @param label 
     * @param orderBy 
     */
    apiContactsCategoriesByCategoryIdPut(params: {  "categoryId": string; "label"?: string; "orderBy"?: number; }, options?: any): FetchArgs {
        // verify required parameter "categoryId" is set
        if (params["categoryId"] == null) {
            throw new Error("Missing required parameter categoryId when calling apiContactsCategoriesByCategoryIdPut");
        }
        const baseUrl = `/api/Contacts/Categories/{categoryId}`
            .replace(`{${"categoryId"}}`, `${ params["categoryId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "label": params["label"],
            "orderBy": params["orderBy"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param categoryId 
     * @param subCategoryId 
     */
    apiContactsCategoriesByCategoryIdSubCategoriesBySubCategoryIdPeopleGet(params: {  "categoryId": string; "subCategoryId": string; }, options?: any): FetchArgs {
        // verify required parameter "categoryId" is set
        if (params["categoryId"] == null) {
            throw new Error("Missing required parameter categoryId when calling apiContactsCategoriesByCategoryIdSubCategoriesBySubCategoryIdPeopleGet");
        }
        // verify required parameter "subCategoryId" is set
        if (params["subCategoryId"] == null) {
            throw new Error("Missing required parameter subCategoryId when calling apiContactsCategoriesByCategoryIdSubCategoriesBySubCategoryIdPeopleGet");
        }
        const baseUrl = `/api/Contacts/Categories/{categoryId}/SubCategories/{subCategoryId}/People`
            .replace(`{${"categoryId"}}`, `${ params["categoryId"] }`)
            .replace(`{${"subCategoryId"}}`, `${ params["subCategoryId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param categoryId 
     */
    apiContactsCategoriesByCategoryIdSubCategoriesGet(params: {  "categoryId": string; }, options?: any): FetchArgs {
        // verify required parameter "categoryId" is set
        if (params["categoryId"] == null) {
            throw new Error("Missing required parameter categoryId when calling apiContactsCategoriesByCategoryIdSubCategoriesGet");
        }
        const baseUrl = `/api/Contacts/Categories/{categoryId}/SubCategories`
            .replace(`{${"categoryId"}}`, `${ params["categoryId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     */
    apiContactsCategoriesGet(options?: any): FetchArgs {
        const baseUrl = `/api/Contacts/Categories`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * *Auth Required
     * @param label 
     * @param orderBy 
     */
    apiContactsCategoriesPost(params: {  "label"?: string; "orderBy"?: number; }, options?: any): FetchArgs {
        const baseUrl = `/api/Contacts/Categories`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "label": params["label"],
            "orderBy": params["orderBy"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ContactCategoriesApi - functional programming interface
 */
export const ContactCategoriesApiFp = {
    /** 
     * *Auth Required
     * @param categoryId 
     */
    apiContactsCategoriesByCategoryIdDelete(params: { "categoryId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContactCategoriesApiFetchParamCreator.apiContactsCategoriesByCategoryIdDelete(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param categoryId 
     */
    apiContactsCategoriesByCategoryIdPeopleGet(params: { "categoryId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse2001>> {
        const fetchArgs = ContactCategoriesApiFetchParamCreator.apiContactsCategoriesByCategoryIdPeopleGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * *Auth Required
     * @param categoryId 
     * @param label 
     * @param orderBy 
     */
    apiContactsCategoriesByCategoryIdPut(params: { "categoryId": string; "label"?: string; "orderBy"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200ContactSubCategoriesUpsert> {
        const fetchArgs = ContactCategoriesApiFetchParamCreator.apiContactsCategoriesByCategoryIdPut(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param categoryId 
     * @param subCategoryId 
     */
    apiContactsCategoriesByCategoryIdSubCategoriesBySubCategoryIdPeopleGet(params: { "categoryId": string; "subCategoryId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse2001>> {
        const fetchArgs = ContactCategoriesApiFetchParamCreator.apiContactsCategoriesByCategoryIdSubCategoriesBySubCategoryIdPeopleGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param categoryId 
     */
    apiContactsCategoriesByCategoryIdSubCategoriesGet(params: { "categoryId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse200ContactSubCategoriesUpsert>> {
        const fetchArgs = ContactCategoriesApiFetchParamCreator.apiContactsCategoriesByCategoryIdSubCategoriesGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     */
    apiContactsCategoriesGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse200ContactSubCategoriesUpsert>> {
        const fetchArgs = ContactCategoriesApiFetchParamCreator.apiContactsCategoriesGet(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * *Auth Required
     * @param label 
     * @param orderBy 
     */
    apiContactsCategoriesPost(params: { "label"?: string; "orderBy"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200ContactSubCategoriesUpsert> {
        const fetchArgs = ContactCategoriesApiFetchParamCreator.apiContactsCategoriesPost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ContactCategoriesApi - object-oriented interface
 */
export class ContactCategoriesApi extends BaseAPI {
    /** 
     * *Auth Required
     * @param categoryId 
     */
    apiContactsCategoriesByCategoryIdDelete(params: {  "categoryId": string; }, options?: any) {
        return ContactCategoriesApiFp.apiContactsCategoriesByCategoryIdDelete(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param categoryId 
     */
    apiContactsCategoriesByCategoryIdPeopleGet(params: {  "categoryId": string; }, options?: any) {
        return ContactCategoriesApiFp.apiContactsCategoriesByCategoryIdPeopleGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * *Auth Required
     * @param categoryId 
     * @param label 
     * @param orderBy 
     */
    apiContactsCategoriesByCategoryIdPut(params: {  "categoryId": string; "label"?: string; "orderBy"?: number; }, options?: any) {
        return ContactCategoriesApiFp.apiContactsCategoriesByCategoryIdPut(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param categoryId 
     * @param subCategoryId 
     */
    apiContactsCategoriesByCategoryIdSubCategoriesBySubCategoryIdPeopleGet(params: {  "categoryId": string; "subCategoryId": string; }, options?: any) {
        return ContactCategoriesApiFp.apiContactsCategoriesByCategoryIdSubCategoriesBySubCategoryIdPeopleGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param categoryId 
     */
    apiContactsCategoriesByCategoryIdSubCategoriesGet(params: {  "categoryId": string; }, options?: any) {
        return ContactCategoriesApiFp.apiContactsCategoriesByCategoryIdSubCategoriesGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     */
    apiContactsCategoriesGet(options?: any) {
        return ContactCategoriesApiFp.apiContactsCategoriesGet(options)(this.fetch, this.basePath);
    }
    /** 
     * *Auth Required
     * @param label 
     * @param orderBy 
     */
    apiContactsCategoriesPost(params: {  "label"?: string; "orderBy"?: number; }, options?: any) {
        return ContactCategoriesApiFp.apiContactsCategoriesPost(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ContactCategoriesApi - factory interface
 */
export const ContactCategoriesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * *Auth Required
         * @param categoryId 
         */
        apiContactsCategoriesByCategoryIdDelete(params: {  "categoryId": string; }, options?: any) {
            return ContactCategoriesApiFp.apiContactsCategoriesByCategoryIdDelete(params, options)(fetch, basePath);
        },
        /** 
         * @param categoryId 
         */
        apiContactsCategoriesByCategoryIdPeopleGet(params: {  "categoryId": string; }, options?: any) {
            return ContactCategoriesApiFp.apiContactsCategoriesByCategoryIdPeopleGet(params, options)(fetch, basePath);
        },
        /** 
         * *Auth Required
         * @param categoryId 
         * @param label 
         * @param orderBy 
         */
        apiContactsCategoriesByCategoryIdPut(params: {  "categoryId": string; "label"?: string; "orderBy"?: number; }, options?: any) {
            return ContactCategoriesApiFp.apiContactsCategoriesByCategoryIdPut(params, options)(fetch, basePath);
        },
        /** 
         * @param categoryId 
         * @param subCategoryId 
         */
        apiContactsCategoriesByCategoryIdSubCategoriesBySubCategoryIdPeopleGet(params: {  "categoryId": string; "subCategoryId": string; }, options?: any) {
            return ContactCategoriesApiFp.apiContactsCategoriesByCategoryIdSubCategoriesBySubCategoryIdPeopleGet(params, options)(fetch, basePath);
        },
        /** 
         * @param categoryId 
         */
        apiContactsCategoriesByCategoryIdSubCategoriesGet(params: {  "categoryId": string; }, options?: any) {
            return ContactCategoriesApiFp.apiContactsCategoriesByCategoryIdSubCategoriesGet(params, options)(fetch, basePath);
        },
        /** 
         */
        apiContactsCategoriesGet(options?: any) {
            return ContactCategoriesApiFp.apiContactsCategoriesGet(options)(fetch, basePath);
        },
        /** 
         * *Auth Required
         * @param label 
         * @param orderBy 
         */
        apiContactsCategoriesPost(params: {  "label"?: string; "orderBy"?: number; }, options?: any) {
            return ContactCategoriesApiFp.apiContactsCategoriesPost(params, options)(fetch, basePath);
        },
    };
};


/**
 * ContactPeopleApi - fetch parameter creator
 */
export const ContactPeopleApiFetchParamCreator = {
    /** 
     * *Auth Required
     * @param personId 
     * @param categoryId 
     */
    apiContactsPeopleByPersonIdAddToCategoryPost(params: {  "personId": string; "categoryId"?: string; }, options?: any): FetchArgs {
        // verify required parameter "personId" is set
        if (params["personId"] == null) {
            throw new Error("Missing required parameter personId when calling apiContactsPeopleByPersonIdAddToCategoryPost");
        }
        const baseUrl = `/api/Contacts/People/{personId}/AddToCategory`
            .replace(`{${"personId"}}`, `${ params["personId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "categoryId": params["categoryId"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * *Auth Required
     * @param personId 
     * @param categoryId 
     * @param subCategoryId 
     */
    apiContactsPeopleByPersonIdAddToSubCategoryPost(params: {  "personId": string; "categoryId"?: string; "subCategoryId"?: string; }, options?: any): FetchArgs {
        // verify required parameter "personId" is set
        if (params["personId"] == null) {
            throw new Error("Missing required parameter personId when calling apiContactsPeopleByPersonIdAddToSubCategoryPost");
        }
        const baseUrl = `/api/Contacts/People/{personId}/AddToSubCategory`
            .replace(`{${"personId"}}`, `${ params["personId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "categoryId": params["categoryId"],
            "subCategoryId": params["subCategoryId"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param personId 
     */
    apiContactsPeopleByPersonIdCategoriesGet(params: {  "personId": string; }, options?: any): FetchArgs {
        // verify required parameter "personId" is set
        if (params["personId"] == null) {
            throw new Error("Missing required parameter personId when calling apiContactsPeopleByPersonIdCategoriesGet");
        }
        const baseUrl = `/api/Contacts/People/{personId}/Categories`
            .replace(`{${"personId"}}`, `${ params["personId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * *Auth Required
     * @param personId 
     */
    apiContactsPeopleByPersonIdDelete(params: {  "personId": string; }, options?: any): FetchArgs {
        // verify required parameter "personId" is set
        if (params["personId"] == null) {
            throw new Error("Missing required parameter personId when calling apiContactsPeopleByPersonIdDelete");
        }
        const baseUrl = `/api/Contacts/People/{personId}`
            .replace(`{${"personId"}}`, `${ params["personId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param personId 
     */
    apiContactsPeopleByPersonIdGet(params: {  "personId": string; }, options?: any): FetchArgs {
        // verify required parameter "personId" is set
        if (params["personId"] == null) {
            throw new Error("Missing required parameter personId when calling apiContactsPeopleByPersonIdGet");
        }
        const baseUrl = `/api/Contacts/People/{personId}`
            .replace(`{${"personId"}}`, `${ params["personId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param personId 
     * @param width 
     * @param height 
     */
    apiContactsPeopleByPersonIdPictureGet(params: {  "personId": string; "width"?: number; "height"?: number; }, options?: any): FetchArgs {
        // verify required parameter "personId" is set
        if (params["personId"] == null) {
            throw new Error("Missing required parameter personId when calling apiContactsPeopleByPersonIdPictureGet");
        }
        const baseUrl = `/api/Contacts/People/{personId}/Picture`
            .replace(`{${"personId"}}`, `${ params["personId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "width": params["width"],
            "height": params["height"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * *Auth Required
     * @param personId 
     * @param uploadedFile 
     */
    apiContactsPeopleByPersonIdPicturePost(params: {  "personId": string; "uploadedFile"?: any; }, options?: any): FetchArgs {
        // verify required parameter "personId" is set
        if (params["personId"] == null) {
            throw new Error("Missing required parameter personId when calling apiContactsPeopleByPersonIdPicturePost");
        }
        const baseUrl = `/api/Contacts/People/{personId}/Picture`
            .replace(`{${"personId"}}`, `${ params["personId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "uploadedFile": params["uploadedFile"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * *Auth Required
     * @param personId 
     * @param region 
     * @param firstName 
     * @param lastName 
     * @param phone 
     * @param cell 
     * @param email 
     */
    apiContactsPeopleByPersonIdPut(params: {  "personId": string; "region"?: string; "firstName"?: string; "lastName"?: string; "phone"?: string; "cell"?: string; "email"?: string; }, options?: any): FetchArgs {
        // verify required parameter "personId" is set
        if (params["personId"] == null) {
            throw new Error("Missing required parameter personId when calling apiContactsPeopleByPersonIdPut");
        }
        const baseUrl = `/api/Contacts/People/{personId}`
            .replace(`{${"personId"}}`, `${ params["personId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "Region": params["region"],
            "FirstName": params["firstName"],
            "LastName": params["lastName"],
            "Phone": params["phone"],
            "Cell": params["cell"],
            "Email": params["email"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * *Auth Required
     * @param personId 
     * @param categoryId 
     */
    apiContactsPeopleByPersonIdRemoveFromCategoryDelete(params: {  "personId": string; "categoryId"?: string; }, options?: any): FetchArgs {
        // verify required parameter "personId" is set
        if (params["personId"] == null) {
            throw new Error("Missing required parameter personId when calling apiContactsPeopleByPersonIdRemoveFromCategoryDelete");
        }
        const baseUrl = `/api/Contacts/People/{personId}/RemoveFromCategory`
            .replace(`{${"personId"}}`, `${ params["personId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "categoryId": params["categoryId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * *Auth Required
     * @param personId 
     * @param categoryId 
     * @param subCategoryId 
     */
    apiContactsPeopleByPersonIdRemoveFromSubCategoryDelete(params: {  "personId": string; "categoryId"?: string; "subCategoryId"?: string; }, options?: any): FetchArgs {
        // verify required parameter "personId" is set
        if (params["personId"] == null) {
            throw new Error("Missing required parameter personId when calling apiContactsPeopleByPersonIdRemoveFromSubCategoryDelete");
        }
        const baseUrl = `/api/Contacts/People/{personId}/RemoveFromSubCategory`
            .replace(`{${"personId"}}`, `${ params["personId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "categoryId": params["categoryId"],
            "subCategoryId": params["subCategoryId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     */
    apiContactsPeopleGet(options?: any): FetchArgs {
        const baseUrl = `/api/Contacts/People`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * *Auth Required
     * @param region 
     * @param firstName 
     * @param lastName 
     * @param phone 
     * @param cell 
     * @param email 
     * @param uploadedFile 
     */
    apiContactsPeoplePost(params: {  "region"?: string; "firstName"?: string; "lastName"?: string; "phone"?: string; "cell"?: string; "email"?: string; "uploadedFile"?: any; }, options?: any): FetchArgs {
        const baseUrl = `/api/Contacts/People`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "Region": params["region"],
            "FirstName": params["firstName"],
            "LastName": params["lastName"],
            "Phone": params["phone"],
            "Cell": params["cell"],
            "Email": params["email"],
            "uploadedFile": params["uploadedFile"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ContactPeopleApi - functional programming interface
 */
export const ContactPeopleApiFp = {
    /** 
     * *Auth Required
     * @param personId 
     * @param categoryId 
     */
    apiContactsPeopleByPersonIdAddToCategoryPost(params: { "personId": string; "categoryId"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContactPeopleApiFetchParamCreator.apiContactsPeopleByPersonIdAddToCategoryPost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * *Auth Required
     * @param personId 
     * @param categoryId 
     * @param subCategoryId 
     */
    apiContactsPeopleByPersonIdAddToSubCategoryPost(params: { "personId": string; "categoryId"?: string; "subCategoryId"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContactPeopleApiFetchParamCreator.apiContactsPeopleByPersonIdAddToSubCategoryPost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param personId 
     */
    apiContactsPeopleByPersonIdCategoriesGet(params: { "personId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse2002>> {
        const fetchArgs = ContactPeopleApiFetchParamCreator.apiContactsPeopleByPersonIdCategoriesGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * *Auth Required
     * @param personId 
     */
    apiContactsPeopleByPersonIdDelete(params: { "personId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContactPeopleApiFetchParamCreator.apiContactsPeopleByPersonIdDelete(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param personId 
     */
    apiContactsPeopleByPersonIdGet(params: { "personId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = ContactPeopleApiFetchParamCreator.apiContactsPeopleByPersonIdGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param personId 
     * @param width 
     * @param height 
     */
    apiContactsPeopleByPersonIdPictureGet(params: { "personId": string; "width"?: number; "height"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContactPeopleApiFetchParamCreator.apiContactsPeopleByPersonIdPictureGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * *Auth Required
     * @param personId 
     * @param uploadedFile 
     */
    apiContactsPeopleByPersonIdPicturePost(params: { "personId": string; "uploadedFile"?: any;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContactPeopleApiFetchParamCreator.apiContactsPeopleByPersonIdPicturePost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * *Auth Required
     * @param personId 
     * @param region 
     * @param firstName 
     * @param lastName 
     * @param phone 
     * @param cell 
     * @param email 
     */
    apiContactsPeopleByPersonIdPut(params: { "personId": string; "region"?: string; "firstName"?: string; "lastName"?: string; "phone"?: string; "cell"?: string; "email"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = ContactPeopleApiFetchParamCreator.apiContactsPeopleByPersonIdPut(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * *Auth Required
     * @param personId 
     * @param categoryId 
     */
    apiContactsPeopleByPersonIdRemoveFromCategoryDelete(params: { "personId": string; "categoryId"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContactPeopleApiFetchParamCreator.apiContactsPeopleByPersonIdRemoveFromCategoryDelete(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * *Auth Required
     * @param personId 
     * @param categoryId 
     * @param subCategoryId 
     */
    apiContactsPeopleByPersonIdRemoveFromSubCategoryDelete(params: { "personId": string; "categoryId"?: string; "subCategoryId"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContactPeopleApiFetchParamCreator.apiContactsPeopleByPersonIdRemoveFromSubCategoryDelete(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     */
    apiContactsPeopleGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse2001>> {
        const fetchArgs = ContactPeopleApiFetchParamCreator.apiContactsPeopleGet(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * *Auth Required
     * @param region 
     * @param firstName 
     * @param lastName 
     * @param phone 
     * @param cell 
     * @param email 
     * @param uploadedFile 
     */
    apiContactsPeoplePost(params: { "region"?: string; "firstName"?: string; "lastName"?: string; "phone"?: string; "cell"?: string; "email"?: string; "uploadedFile"?: any;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = ContactPeopleApiFetchParamCreator.apiContactsPeoplePost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ContactPeopleApi - object-oriented interface
 */
export class ContactPeopleApi extends BaseAPI {
    /** 
     * *Auth Required
     * @param personId 
     * @param categoryId 
     */
    apiContactsPeopleByPersonIdAddToCategoryPost(params: {  "personId": string; "categoryId"?: string; }, options?: any) {
        return ContactPeopleApiFp.apiContactsPeopleByPersonIdAddToCategoryPost(params, options)(this.fetch, this.basePath);
    }
    /** 
     * *Auth Required
     * @param personId 
     * @param categoryId 
     * @param subCategoryId 
     */
    apiContactsPeopleByPersonIdAddToSubCategoryPost(params: {  "personId": string; "categoryId"?: string; "subCategoryId"?: string; }, options?: any) {
        return ContactPeopleApiFp.apiContactsPeopleByPersonIdAddToSubCategoryPost(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param personId 
     */
    apiContactsPeopleByPersonIdCategoriesGet(params: {  "personId": string; }, options?: any) {
        return ContactPeopleApiFp.apiContactsPeopleByPersonIdCategoriesGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * *Auth Required
     * @param personId 
     */
    apiContactsPeopleByPersonIdDelete(params: {  "personId": string; }, options?: any) {
        return ContactPeopleApiFp.apiContactsPeopleByPersonIdDelete(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param personId 
     */
    apiContactsPeopleByPersonIdGet(params: {  "personId": string; }, options?: any) {
        return ContactPeopleApiFp.apiContactsPeopleByPersonIdGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param personId 
     * @param width 
     * @param height 
     */
    apiContactsPeopleByPersonIdPictureGet(params: {  "personId": string; "width"?: number; "height"?: number; }, options?: any) {
        return ContactPeopleApiFp.apiContactsPeopleByPersonIdPictureGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * *Auth Required
     * @param personId 
     * @param uploadedFile 
     */
    apiContactsPeopleByPersonIdPicturePost(params: {  "personId": string; "uploadedFile"?: any; }, options?: any) {
        return ContactPeopleApiFp.apiContactsPeopleByPersonIdPicturePost(params, options)(this.fetch, this.basePath);
    }
    /** 
     * *Auth Required
     * @param personId 
     * @param region 
     * @param firstName 
     * @param lastName 
     * @param phone 
     * @param cell 
     * @param email 
     */
    apiContactsPeopleByPersonIdPut(params: {  "personId": string; "region"?: string; "firstName"?: string; "lastName"?: string; "phone"?: string; "cell"?: string; "email"?: string; }, options?: any) {
        return ContactPeopleApiFp.apiContactsPeopleByPersonIdPut(params, options)(this.fetch, this.basePath);
    }
    /** 
     * *Auth Required
     * @param personId 
     * @param categoryId 
     */
    apiContactsPeopleByPersonIdRemoveFromCategoryDelete(params: {  "personId": string; "categoryId"?: string; }, options?: any) {
        return ContactPeopleApiFp.apiContactsPeopleByPersonIdRemoveFromCategoryDelete(params, options)(this.fetch, this.basePath);
    }
    /** 
     * *Auth Required
     * @param personId 
     * @param categoryId 
     * @param subCategoryId 
     */
    apiContactsPeopleByPersonIdRemoveFromSubCategoryDelete(params: {  "personId": string; "categoryId"?: string; "subCategoryId"?: string; }, options?: any) {
        return ContactPeopleApiFp.apiContactsPeopleByPersonIdRemoveFromSubCategoryDelete(params, options)(this.fetch, this.basePath);
    }
    /** 
     */
    apiContactsPeopleGet(options?: any) {
        return ContactPeopleApiFp.apiContactsPeopleGet(options)(this.fetch, this.basePath);
    }
    /** 
     * *Auth Required
     * @param region 
     * @param firstName 
     * @param lastName 
     * @param phone 
     * @param cell 
     * @param email 
     * @param uploadedFile 
     */
    apiContactsPeoplePost(params: {  "region"?: string; "firstName"?: string; "lastName"?: string; "phone"?: string; "cell"?: string; "email"?: string; "uploadedFile"?: any; }, options?: any) {
        return ContactPeopleApiFp.apiContactsPeoplePost(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ContactPeopleApi - factory interface
 */
export const ContactPeopleApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * *Auth Required
         * @param personId 
         * @param categoryId 
         */
        apiContactsPeopleByPersonIdAddToCategoryPost(params: {  "personId": string; "categoryId"?: string; }, options?: any) {
            return ContactPeopleApiFp.apiContactsPeopleByPersonIdAddToCategoryPost(params, options)(fetch, basePath);
        },
        /** 
         * *Auth Required
         * @param personId 
         * @param categoryId 
         * @param subCategoryId 
         */
        apiContactsPeopleByPersonIdAddToSubCategoryPost(params: {  "personId": string; "categoryId"?: string; "subCategoryId"?: string; }, options?: any) {
            return ContactPeopleApiFp.apiContactsPeopleByPersonIdAddToSubCategoryPost(params, options)(fetch, basePath);
        },
        /** 
         * @param personId 
         */
        apiContactsPeopleByPersonIdCategoriesGet(params: {  "personId": string; }, options?: any) {
            return ContactPeopleApiFp.apiContactsPeopleByPersonIdCategoriesGet(params, options)(fetch, basePath);
        },
        /** 
         * *Auth Required
         * @param personId 
         */
        apiContactsPeopleByPersonIdDelete(params: {  "personId": string; }, options?: any) {
            return ContactPeopleApiFp.apiContactsPeopleByPersonIdDelete(params, options)(fetch, basePath);
        },
        /** 
         * @param personId 
         */
        apiContactsPeopleByPersonIdGet(params: {  "personId": string; }, options?: any) {
            return ContactPeopleApiFp.apiContactsPeopleByPersonIdGet(params, options)(fetch, basePath);
        },
        /** 
         * @param personId 
         * @param width 
         * @param height 
         */
        apiContactsPeopleByPersonIdPictureGet(params: {  "personId": string; "width"?: number; "height"?: number; }, options?: any) {
            return ContactPeopleApiFp.apiContactsPeopleByPersonIdPictureGet(params, options)(fetch, basePath);
        },
        /** 
         * *Auth Required
         * @param personId 
         * @param uploadedFile 
         */
        apiContactsPeopleByPersonIdPicturePost(params: {  "personId": string; "uploadedFile"?: any; }, options?: any) {
            return ContactPeopleApiFp.apiContactsPeopleByPersonIdPicturePost(params, options)(fetch, basePath);
        },
        /** 
         * *Auth Required
         * @param personId 
         * @param region 
         * @param firstName 
         * @param lastName 
         * @param phone 
         * @param cell 
         * @param email 
         */
        apiContactsPeopleByPersonIdPut(params: {  "personId": string; "region"?: string; "firstName"?: string; "lastName"?: string; "phone"?: string; "cell"?: string; "email"?: string; }, options?: any) {
            return ContactPeopleApiFp.apiContactsPeopleByPersonIdPut(params, options)(fetch, basePath);
        },
        /** 
         * *Auth Required
         * @param personId 
         * @param categoryId 
         */
        apiContactsPeopleByPersonIdRemoveFromCategoryDelete(params: {  "personId": string; "categoryId"?: string; }, options?: any) {
            return ContactPeopleApiFp.apiContactsPeopleByPersonIdRemoveFromCategoryDelete(params, options)(fetch, basePath);
        },
        /** 
         * *Auth Required
         * @param personId 
         * @param categoryId 
         * @param subCategoryId 
         */
        apiContactsPeopleByPersonIdRemoveFromSubCategoryDelete(params: {  "personId": string; "categoryId"?: string; "subCategoryId"?: string; }, options?: any) {
            return ContactPeopleApiFp.apiContactsPeopleByPersonIdRemoveFromSubCategoryDelete(params, options)(fetch, basePath);
        },
        /** 
         */
        apiContactsPeopleGet(options?: any) {
            return ContactPeopleApiFp.apiContactsPeopleGet(options)(fetch, basePath);
        },
        /** 
         * *Auth Required
         * @param region 
         * @param firstName 
         * @param lastName 
         * @param phone 
         * @param cell 
         * @param email 
         * @param uploadedFile 
         */
        apiContactsPeoplePost(params: {  "region"?: string; "firstName"?: string; "lastName"?: string; "phone"?: string; "cell"?: string; "email"?: string; "uploadedFile"?: any; }, options?: any) {
            return ContactPeopleApiFp.apiContactsPeoplePost(params, options)(fetch, basePath);
        },
    };
};


/**
 * ContactSubCategoriesApi - fetch parameter creator
 */
export const ContactSubCategoriesApiFetchParamCreator = {
    /** 
     * *Auth Required
     * @param subCategoryId 
     * @param categoryId 
     */
    apiContactsSubCategoriesBySubCategoryIdAddToCategoryPost(params: {  "subCategoryId": string; "categoryId"?: string; }, options?: any): FetchArgs {
        // verify required parameter "subCategoryId" is set
        if (params["subCategoryId"] == null) {
            throw new Error("Missing required parameter subCategoryId when calling apiContactsSubCategoriesBySubCategoryIdAddToCategoryPost");
        }
        const baseUrl = `/api/Contacts/SubCategories/{subCategoryId}/AddToCategory`
            .replace(`{${"subCategoryId"}}`, `${ params["subCategoryId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "categoryId": params["categoryId"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * *Auth Required
     * @param subCategoryId 
     */
    apiContactsSubCategoriesBySubCategoryIdDelete(params: {  "subCategoryId": string; }, options?: any): FetchArgs {
        // verify required parameter "subCategoryId" is set
        if (params["subCategoryId"] == null) {
            throw new Error("Missing required parameter subCategoryId when calling apiContactsSubCategoriesBySubCategoryIdDelete");
        }
        const baseUrl = `/api/Contacts/SubCategories/{subCategoryId}`
            .replace(`{${"subCategoryId"}}`, `${ params["subCategoryId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param subCategoryId 
     */
    apiContactsSubCategoriesBySubCategoryIdGet(params: {  "subCategoryId": string; }, options?: any): FetchArgs {
        // verify required parameter "subCategoryId" is set
        if (params["subCategoryId"] == null) {
            throw new Error("Missing required parameter subCategoryId when calling apiContactsSubCategoriesBySubCategoryIdGet");
        }
        const baseUrl = `/api/Contacts/SubCategories/{subCategoryId}`
            .replace(`{${"subCategoryId"}}`, `${ params["subCategoryId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * *Auth Required
     * @param subCategoryId 
     * @param label 
     * @param orderBy 
     */
    apiContactsSubCategoriesBySubCategoryIdPut(params: {  "subCategoryId": string; "label"?: string; "orderBy"?: number; }, options?: any): FetchArgs {
        // verify required parameter "subCategoryId" is set
        if (params["subCategoryId"] == null) {
            throw new Error("Missing required parameter subCategoryId when calling apiContactsSubCategoriesBySubCategoryIdPut");
        }
        const baseUrl = `/api/Contacts/SubCategories/{subCategoryId}`
            .replace(`{${"subCategoryId"}}`, `${ params["subCategoryId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "label": params["label"],
            "orderBy": params["orderBy"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * *Auth Required
     * @param subCategoryId 
     * @param categoryId 
     */
    apiContactsSubCategoriesBySubCategoryIdRemoveFromCategoryDelete(params: {  "subCategoryId": string; "categoryId"?: string; }, options?: any): FetchArgs {
        // verify required parameter "subCategoryId" is set
        if (params["subCategoryId"] == null) {
            throw new Error("Missing required parameter subCategoryId when calling apiContactsSubCategoriesBySubCategoryIdRemoveFromCategoryDelete");
        }
        const baseUrl = `/api/Contacts/SubCategories/{subCategoryId}/RemoveFromCategory`
            .replace(`{${"subCategoryId"}}`, `${ params["subCategoryId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "categoryId": params["categoryId"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     */
    apiContactsSubCategoriesGet(options?: any): FetchArgs {
        const baseUrl = `/api/Contacts/SubCategories`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * *Auth Required
     * @param label 
     * @param orderBy 
     */
    apiContactsSubCategoriesPost(params: {  "label"?: string; "orderBy"?: number; }, options?: any): FetchArgs {
        const baseUrl = `/api/Contacts/SubCategories`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "label": params["label"],
            "orderBy": params["orderBy"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ContactSubCategoriesApi - functional programming interface
 */
export const ContactSubCategoriesApiFp = {
    /** 
     * *Auth Required
     * @param subCategoryId 
     * @param categoryId 
     */
    apiContactsSubCategoriesBySubCategoryIdAddToCategoryPost(params: { "subCategoryId": string; "categoryId"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContactSubCategoriesApiFetchParamCreator.apiContactsSubCategoriesBySubCategoryIdAddToCategoryPost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * *Auth Required
     * @param subCategoryId 
     */
    apiContactsSubCategoriesBySubCategoryIdDelete(params: { "subCategoryId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContactSubCategoriesApiFetchParamCreator.apiContactsSubCategoriesBySubCategoryIdDelete(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param subCategoryId 
     */
    apiContactsSubCategoriesBySubCategoryIdGet(params: { "subCategoryId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200ContactSubCategoriesUpsert> {
        const fetchArgs = ContactSubCategoriesApiFetchParamCreator.apiContactsSubCategoriesBySubCategoryIdGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * *Auth Required
     * @param subCategoryId 
     * @param label 
     * @param orderBy 
     */
    apiContactsSubCategoriesBySubCategoryIdPut(params: { "subCategoryId": string; "label"?: string; "orderBy"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200ContactSubCategoriesUpsert> {
        const fetchArgs = ContactSubCategoriesApiFetchParamCreator.apiContactsSubCategoriesBySubCategoryIdPut(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * *Auth Required
     * @param subCategoryId 
     * @param categoryId 
     */
    apiContactsSubCategoriesBySubCategoryIdRemoveFromCategoryDelete(params: { "subCategoryId": string; "categoryId"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContactSubCategoriesApiFetchParamCreator.apiContactsSubCategoriesBySubCategoryIdRemoveFromCategoryDelete(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     */
    apiContactsSubCategoriesGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse200ContactSubCategoriesUpsert>> {
        const fetchArgs = ContactSubCategoriesApiFetchParamCreator.apiContactsSubCategoriesGet(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * *Auth Required
     * @param label 
     * @param orderBy 
     */
    apiContactsSubCategoriesPost(params: { "label"?: string; "orderBy"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200ContactSubCategoriesUpsert> {
        const fetchArgs = ContactSubCategoriesApiFetchParamCreator.apiContactsSubCategoriesPost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ContactSubCategoriesApi - object-oriented interface
 */
export class ContactSubCategoriesApi extends BaseAPI {
    /** 
     * *Auth Required
     * @param subCategoryId 
     * @param categoryId 
     */
    apiContactsSubCategoriesBySubCategoryIdAddToCategoryPost(params: {  "subCategoryId": string; "categoryId"?: string; }, options?: any) {
        return ContactSubCategoriesApiFp.apiContactsSubCategoriesBySubCategoryIdAddToCategoryPost(params, options)(this.fetch, this.basePath);
    }
    /** 
     * *Auth Required
     * @param subCategoryId 
     */
    apiContactsSubCategoriesBySubCategoryIdDelete(params: {  "subCategoryId": string; }, options?: any) {
        return ContactSubCategoriesApiFp.apiContactsSubCategoriesBySubCategoryIdDelete(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param subCategoryId 
     */
    apiContactsSubCategoriesBySubCategoryIdGet(params: {  "subCategoryId": string; }, options?: any) {
        return ContactSubCategoriesApiFp.apiContactsSubCategoriesBySubCategoryIdGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * *Auth Required
     * @param subCategoryId 
     * @param label 
     * @param orderBy 
     */
    apiContactsSubCategoriesBySubCategoryIdPut(params: {  "subCategoryId": string; "label"?: string; "orderBy"?: number; }, options?: any) {
        return ContactSubCategoriesApiFp.apiContactsSubCategoriesBySubCategoryIdPut(params, options)(this.fetch, this.basePath);
    }
    /** 
     * *Auth Required
     * @param subCategoryId 
     * @param categoryId 
     */
    apiContactsSubCategoriesBySubCategoryIdRemoveFromCategoryDelete(params: {  "subCategoryId": string; "categoryId"?: string; }, options?: any) {
        return ContactSubCategoriesApiFp.apiContactsSubCategoriesBySubCategoryIdRemoveFromCategoryDelete(params, options)(this.fetch, this.basePath);
    }
    /** 
     */
    apiContactsSubCategoriesGet(options?: any) {
        return ContactSubCategoriesApiFp.apiContactsSubCategoriesGet(options)(this.fetch, this.basePath);
    }
    /** 
     * *Auth Required
     * @param label 
     * @param orderBy 
     */
    apiContactsSubCategoriesPost(params: {  "label"?: string; "orderBy"?: number; }, options?: any) {
        return ContactSubCategoriesApiFp.apiContactsSubCategoriesPost(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ContactSubCategoriesApi - factory interface
 */
export const ContactSubCategoriesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * *Auth Required
         * @param subCategoryId 
         * @param categoryId 
         */
        apiContactsSubCategoriesBySubCategoryIdAddToCategoryPost(params: {  "subCategoryId": string; "categoryId"?: string; }, options?: any) {
            return ContactSubCategoriesApiFp.apiContactsSubCategoriesBySubCategoryIdAddToCategoryPost(params, options)(fetch, basePath);
        },
        /** 
         * *Auth Required
         * @param subCategoryId 
         */
        apiContactsSubCategoriesBySubCategoryIdDelete(params: {  "subCategoryId": string; }, options?: any) {
            return ContactSubCategoriesApiFp.apiContactsSubCategoriesBySubCategoryIdDelete(params, options)(fetch, basePath);
        },
        /** 
         * @param subCategoryId 
         */
        apiContactsSubCategoriesBySubCategoryIdGet(params: {  "subCategoryId": string; }, options?: any) {
            return ContactSubCategoriesApiFp.apiContactsSubCategoriesBySubCategoryIdGet(params, options)(fetch, basePath);
        },
        /** 
         * *Auth Required
         * @param subCategoryId 
         * @param label 
         * @param orderBy 
         */
        apiContactsSubCategoriesBySubCategoryIdPut(params: {  "subCategoryId": string; "label"?: string; "orderBy"?: number; }, options?: any) {
            return ContactSubCategoriesApiFp.apiContactsSubCategoriesBySubCategoryIdPut(params, options)(fetch, basePath);
        },
        /** 
         * *Auth Required
         * @param subCategoryId 
         * @param categoryId 
         */
        apiContactsSubCategoriesBySubCategoryIdRemoveFromCategoryDelete(params: {  "subCategoryId": string; "categoryId"?: string; }, options?: any) {
            return ContactSubCategoriesApiFp.apiContactsSubCategoriesBySubCategoryIdRemoveFromCategoryDelete(params, options)(fetch, basePath);
        },
        /** 
         */
        apiContactsSubCategoriesGet(options?: any) {
            return ContactSubCategoriesApiFp.apiContactsSubCategoriesGet(options)(fetch, basePath);
        },
        /** 
         * *Auth Required
         * @param label 
         * @param orderBy 
         */
        apiContactsSubCategoriesPost(params: {  "label"?: string; "orderBy"?: number; }, options?: any) {
            return ContactSubCategoriesApiFp.apiContactsSubCategoriesPost(params, options)(fetch, basePath);
        },
    };
};


/**
 * LpcApi - fetch parameter creator
 */
export const LpcApiFetchParamCreator = {
    /** 
     * *Auth Required
     * @param id 
     */
    apiLpcByIdDelete(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling apiLpcByIdDelete");
        }
        const baseUrl = `/api/Lpc/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param id 
     */
    apiLpcByIdGet(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling apiLpcByIdGet");
        }
        const baseUrl = `/api/Lpc/{id})`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param id 
     * @param width 
     * @param height 
     */
    apiLpcByIdIconGet(params: {  "id": string; "width"?: number; "height"?: number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling apiLpcByIdIconGet");
        }
        const baseUrl = `/api/Lpc/{id}/Icon`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "width": params["width"],
            "height": params["height"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * *Auth Required
     * @param id 
     * @param icon 
     */
    apiLpcByIdIconPost(params: {  "id": string; "icon"?: any; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling apiLpcByIdIconPost");
        }
        const baseUrl = `/api/Lpc/{id}/Icon`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "icon": params["icon"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param id 
     * @param width 
     * @param height 
     */
    apiLpcByIdPhotoGet(params: {  "id": string; "width"?: number; "height"?: number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling apiLpcByIdPhotoGet");
        }
        const baseUrl = `/api/Lpc/{id}/Photo`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "width": params["width"],
            "height": params["height"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * *Auth Required
     * @param id 
     * @param photo 
     */
    apiLpcByIdPhotoPost(params: {  "id": string; "photo"?: any; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling apiLpcByIdPhotoPost");
        }
        const baseUrl = `/api/Lpc/{id}/Photo`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "photo": params["photo"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * *Auth Required
     * @param id 
     * @param name MaxLen:100
     * @param address1 MaxLen:100
     * @param city1 MaxLen:50
     * @param state1 MaxLen:2
     * @param zip1 MaxLen:50
     * @param address2 MaxLen:100
     * @param city2 MaxLen:50
     * @param state2 MaxLen:2
     * @param zip2 MaxLen:50
     * @param web MaxLen:100
     * @param phone MaxLen:10,Phone number
     * @param fax MaxLen:10,Phone number
     * @param totalElectricCustomers 
     * @param residentialCustomers 
     * @param cICustomersLessThan50kw 
     * @param cICustomers51To4999Kw 
     * @param cICustomersGreaterThan5000kw 
     * @param totalNaturalGasCustomers 
     * @param totalWaterCustomers 
     * @param totalWastewaterCustomers 
     * @param totalSystemAssets 
     * @param taxes 
     * @param milesOfLine 
     * @param customersPerMile 
     * @param avgResidentialUseInKwhPerMonth 
     * @param deliveryPoints 
     * @param avgLoadFactor 
     * @param photo 
     * @param icon 
     */
    apiLpcByIdPut(params: {  "id": string; "name"?: string; "address1"?: string; "city1"?: string; "state1"?: string; "zip1"?: string; "address2"?: string; "city2"?: string; "state2"?: string; "zip2"?: string; "web"?: string; "phone"?: string; "fax"?: string; "totalElectricCustomers"?: number; "residentialCustomers"?: number; "cICustomersLessThan50kw"?: number; "cICustomers51To4999Kw"?: number; "cICustomersGreaterThan5000kw"?: number; "totalNaturalGasCustomers"?: number; "totalWaterCustomers"?: number; "totalWastewaterCustomers"?: number; "totalSystemAssets"?: number; "taxes"?: number; "milesOfLine"?: number; "customersPerMile"?: number; "avgResidentialUseInKwhPerMonth"?: number; "deliveryPoints"?: number; "avgLoadFactor"?: number; "photo"?: any; "icon"?: any; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling apiLpcByIdPut");
        }
        const baseUrl = `/api/Lpc/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "Name": params["name"],
            "Address1": params["address1"],
            "City1": params["city1"],
            "State1": params["state1"],
            "Zip1": params["zip1"],
            "Address2": params["address2"],
            "City2": params["city2"],
            "State2": params["state2"],
            "Zip2": params["zip2"],
            "Web": params["web"],
            "Phone": params["phone"],
            "Fax": params["fax"],
            "TotalElectricCustomers": params["totalElectricCustomers"],
            "ResidentialCustomers": params["residentialCustomers"],
            "CICustomersLessThan50kw": params["cICustomersLessThan50kw"],
            "CICustomers51To4999Kw": params["cICustomers51To4999Kw"],
            "CICustomersGreaterThan5000kw": params["cICustomersGreaterThan5000kw"],
            "TotalNaturalGasCustomers": params["totalNaturalGasCustomers"],
            "TotalWaterCustomers": params["totalWaterCustomers"],
            "TotalWastewaterCustomers": params["totalWastewaterCustomers"],
            "TotalSystemAssets": params["totalSystemAssets"],
            "Taxes": params["taxes"],
            "MilesOfLine": params["milesOfLine"],
            "CustomersPerMile": params["customersPerMile"],
            "AvgResidentialUseInKwhPerMonth": params["avgResidentialUseInKwhPerMonth"],
            "DeliveryPoints": params["deliveryPoints"],
            "AvgLoadFactor": params["avgLoadFactor"],
            "photo": params["photo"],
            "icon": params["icon"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     */
    apiLpcGet(options?: any): FetchArgs {
        const baseUrl = `/api/Lpc`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * *Auth Required
     * @param name MaxLen:100
     * @param address1 MaxLen:100
     * @param city1 MaxLen:50
     * @param state1 MaxLen:2
     * @param zip1 MaxLen:50
     * @param address2 MaxLen:100
     * @param city2 MaxLen:50
     * @param state2 MaxLen:2
     * @param zip2 MaxLen:50
     * @param web MaxLen:100
     * @param phone MaxLen:10,Phone number
     * @param fax MaxLen:10,Phone number
     * @param totalElectricCustomers 
     * @param residentialCustomers 
     * @param cICustomersLessThan50kw 
     * @param cICustomers51To4999Kw 
     * @param cICustomersGreaterThan5000kw 
     * @param totalNaturalGasCustomers 
     * @param totalWaterCustomers 
     * @param totalWastewaterCustomers 
     * @param totalSystemAssets 
     * @param taxes 
     * @param milesOfLine 
     * @param customersPerMile 
     * @param avgResidentialUseInKwhPerMonth 
     * @param deliveryPoints 
     * @param avgLoadFactor 
     * @param photo 
     * @param icon 
     */
    apiLpcPost(params: {  "name"?: string; "address1"?: string; "city1"?: string; "state1"?: string; "zip1"?: string; "address2"?: string; "city2"?: string; "state2"?: string; "zip2"?: string; "web"?: string; "phone"?: string; "fax"?: string; "totalElectricCustomers"?: number; "residentialCustomers"?: number; "cICustomersLessThan50kw"?: number; "cICustomers51To4999Kw"?: number; "cICustomersGreaterThan5000kw"?: number; "totalNaturalGasCustomers"?: number; "totalWaterCustomers"?: number; "totalWastewaterCustomers"?: number; "totalSystemAssets"?: number; "taxes"?: number; "milesOfLine"?: number; "customersPerMile"?: number; "avgResidentialUseInKwhPerMonth"?: number; "deliveryPoints"?: number; "avgLoadFactor"?: number; "photo"?: any; "icon"?: any; }, options?: any): FetchArgs {
        const baseUrl = `/api/Lpc`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "Name": params["name"],
            "Address1": params["address1"],
            "City1": params["city1"],
            "State1": params["state1"],
            "Zip1": params["zip1"],
            "Address2": params["address2"],
            "City2": params["city2"],
            "State2": params["state2"],
            "Zip2": params["zip2"],
            "Web": params["web"],
            "Phone": params["phone"],
            "Fax": params["fax"],
            "TotalElectricCustomers": params["totalElectricCustomers"],
            "ResidentialCustomers": params["residentialCustomers"],
            "CICustomersLessThan50kw": params["cICustomersLessThan50kw"],
            "CICustomers51To4999Kw": params["cICustomers51To4999Kw"],
            "CICustomersGreaterThan5000kw": params["cICustomersGreaterThan5000kw"],
            "TotalNaturalGasCustomers": params["totalNaturalGasCustomers"],
            "TotalWaterCustomers": params["totalWaterCustomers"],
            "TotalWastewaterCustomers": params["totalWastewaterCustomers"],
            "TotalSystemAssets": params["totalSystemAssets"],
            "Taxes": params["taxes"],
            "MilesOfLine": params["milesOfLine"],
            "CustomersPerMile": params["customersPerMile"],
            "AvgResidentialUseInKwhPerMonth": params["avgResidentialUseInKwhPerMonth"],
            "DeliveryPoints": params["deliveryPoints"],
            "AvgLoadFactor": params["avgLoadFactor"],
            "photo": params["photo"],
            "icon": params["icon"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * LpcApi - functional programming interface
 */
export const LpcApiFp = {
    /** 
     * *Auth Required
     * @param id 
     */
    apiLpcByIdDelete(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = LpcApiFetchParamCreator.apiLpcByIdDelete(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param id 
     */
    apiLpcByIdGet(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = LpcApiFetchParamCreator.apiLpcByIdGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param id 
     * @param width 
     * @param height 
     */
    apiLpcByIdIconGet(params: { "id": string; "width"?: number; "height"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = LpcApiFetchParamCreator.apiLpcByIdIconGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * *Auth Required
     * @param id 
     * @param icon 
     */
    apiLpcByIdIconPost(params: { "id": string; "icon"?: any;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = LpcApiFetchParamCreator.apiLpcByIdIconPost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param id 
     * @param width 
     * @param height 
     */
    apiLpcByIdPhotoGet(params: { "id": string; "width"?: number; "height"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = LpcApiFetchParamCreator.apiLpcByIdPhotoGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * *Auth Required
     * @param id 
     * @param photo 
     */
    apiLpcByIdPhotoPost(params: { "id": string; "photo"?: any;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = LpcApiFetchParamCreator.apiLpcByIdPhotoPost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * *Auth Required
     * @param id 
     * @param name MaxLen:100
     * @param address1 MaxLen:100
     * @param city1 MaxLen:50
     * @param state1 MaxLen:2
     * @param zip1 MaxLen:50
     * @param address2 MaxLen:100
     * @param city2 MaxLen:50
     * @param state2 MaxLen:2
     * @param zip2 MaxLen:50
     * @param web MaxLen:100
     * @param phone MaxLen:10,Phone number
     * @param fax MaxLen:10,Phone number
     * @param totalElectricCustomers 
     * @param residentialCustomers 
     * @param cICustomersLessThan50kw 
     * @param cICustomers51To4999Kw 
     * @param cICustomersGreaterThan5000kw 
     * @param totalNaturalGasCustomers 
     * @param totalWaterCustomers 
     * @param totalWastewaterCustomers 
     * @param totalSystemAssets 
     * @param taxes 
     * @param milesOfLine 
     * @param customersPerMile 
     * @param avgResidentialUseInKwhPerMonth 
     * @param deliveryPoints 
     * @param avgLoadFactor 
     * @param photo 
     * @param icon 
     */
    apiLpcByIdPut(params: { "id": string; "name"?: string; "address1"?: string; "city1"?: string; "state1"?: string; "zip1"?: string; "address2"?: string; "city2"?: string; "state2"?: string; "zip2"?: string; "web"?: string; "phone"?: string; "fax"?: string; "totalElectricCustomers"?: number; "residentialCustomers"?: number; "cICustomersLessThan50kw"?: number; "cICustomers51To4999Kw"?: number; "cICustomersGreaterThan5000kw"?: number; "totalNaturalGasCustomers"?: number; "totalWaterCustomers"?: number; "totalWastewaterCustomers"?: number; "totalSystemAssets"?: number; "taxes"?: number; "milesOfLine"?: number; "customersPerMile"?: number; "avgResidentialUseInKwhPerMonth"?: number; "deliveryPoints"?: number; "avgLoadFactor"?: number; "photo"?: any; "icon"?: any;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = LpcApiFetchParamCreator.apiLpcByIdPut(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     */
    apiLpcGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse2003>> {
        const fetchArgs = LpcApiFetchParamCreator.apiLpcGet(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * *Auth Required
     * @param name MaxLen:100
     * @param address1 MaxLen:100
     * @param city1 MaxLen:50
     * @param state1 MaxLen:2
     * @param zip1 MaxLen:50
     * @param address2 MaxLen:100
     * @param city2 MaxLen:50
     * @param state2 MaxLen:2
     * @param zip2 MaxLen:50
     * @param web MaxLen:100
     * @param phone MaxLen:10,Phone number
     * @param fax MaxLen:10,Phone number
     * @param totalElectricCustomers 
     * @param residentialCustomers 
     * @param cICustomersLessThan50kw 
     * @param cICustomers51To4999Kw 
     * @param cICustomersGreaterThan5000kw 
     * @param totalNaturalGasCustomers 
     * @param totalWaterCustomers 
     * @param totalWastewaterCustomers 
     * @param totalSystemAssets 
     * @param taxes 
     * @param milesOfLine 
     * @param customersPerMile 
     * @param avgResidentialUseInKwhPerMonth 
     * @param deliveryPoints 
     * @param avgLoadFactor 
     * @param photo 
     * @param icon 
     */
    apiLpcPost(params: { "name"?: string; "address1"?: string; "city1"?: string; "state1"?: string; "zip1"?: string; "address2"?: string; "city2"?: string; "state2"?: string; "zip2"?: string; "web"?: string; "phone"?: string; "fax"?: string; "totalElectricCustomers"?: number; "residentialCustomers"?: number; "cICustomersLessThan50kw"?: number; "cICustomers51To4999Kw"?: number; "cICustomersGreaterThan5000kw"?: number; "totalNaturalGasCustomers"?: number; "totalWaterCustomers"?: number; "totalWastewaterCustomers"?: number; "totalSystemAssets"?: number; "taxes"?: number; "milesOfLine"?: number; "customersPerMile"?: number; "avgResidentialUseInKwhPerMonth"?: number; "deliveryPoints"?: number; "avgLoadFactor"?: number; "photo"?: any; "icon"?: any;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = LpcApiFetchParamCreator.apiLpcPost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * LpcApi - object-oriented interface
 */
export class LpcApi extends BaseAPI {
    /** 
     * *Auth Required
     * @param id 
     */
    apiLpcByIdDelete(params: {  "id": string; }, options?: any) {
        return LpcApiFp.apiLpcByIdDelete(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param id 
     */
    apiLpcByIdGet(params: {  "id": string; }, options?: any) {
        return LpcApiFp.apiLpcByIdGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param id 
     * @param width 
     * @param height 
     */
    apiLpcByIdIconGet(params: {  "id": string; "width"?: number; "height"?: number; }, options?: any) {
        return LpcApiFp.apiLpcByIdIconGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * *Auth Required
     * @param id 
     * @param icon 
     */
    apiLpcByIdIconPost(params: {  "id": string; "icon"?: any; }, options?: any) {
        return LpcApiFp.apiLpcByIdIconPost(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param id 
     * @param width 
     * @param height 
     */
    apiLpcByIdPhotoGet(params: {  "id": string; "width"?: number; "height"?: number; }, options?: any) {
        return LpcApiFp.apiLpcByIdPhotoGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * *Auth Required
     * @param id 
     * @param photo 
     */
    apiLpcByIdPhotoPost(params: {  "id": string; "photo"?: any; }, options?: any) {
        return LpcApiFp.apiLpcByIdPhotoPost(params, options)(this.fetch, this.basePath);
    }
    /** 
     * *Auth Required
     * @param id 
     * @param name MaxLen:100
     * @param address1 MaxLen:100
     * @param city1 MaxLen:50
     * @param state1 MaxLen:2
     * @param zip1 MaxLen:50
     * @param address2 MaxLen:100
     * @param city2 MaxLen:50
     * @param state2 MaxLen:2
     * @param zip2 MaxLen:50
     * @param web MaxLen:100
     * @param phone MaxLen:10,Phone number
     * @param fax MaxLen:10,Phone number
     * @param totalElectricCustomers 
     * @param residentialCustomers 
     * @param cICustomersLessThan50kw 
     * @param cICustomers51To4999Kw 
     * @param cICustomersGreaterThan5000kw 
     * @param totalNaturalGasCustomers 
     * @param totalWaterCustomers 
     * @param totalWastewaterCustomers 
     * @param totalSystemAssets 
     * @param taxes 
     * @param milesOfLine 
     * @param customersPerMile 
     * @param avgResidentialUseInKwhPerMonth 
     * @param deliveryPoints 
     * @param avgLoadFactor 
     * @param photo 
     * @param icon 
     */
    apiLpcByIdPut(params: {  "id": string; "name"?: string; "address1"?: string; "city1"?: string; "state1"?: string; "zip1"?: string; "address2"?: string; "city2"?: string; "state2"?: string; "zip2"?: string; "web"?: string; "phone"?: string; "fax"?: string; "totalElectricCustomers"?: number; "residentialCustomers"?: number; "cICustomersLessThan50kw"?: number; "cICustomers51To4999Kw"?: number; "cICustomersGreaterThan5000kw"?: number; "totalNaturalGasCustomers"?: number; "totalWaterCustomers"?: number; "totalWastewaterCustomers"?: number; "totalSystemAssets"?: number; "taxes"?: number; "milesOfLine"?: number; "customersPerMile"?: number; "avgResidentialUseInKwhPerMonth"?: number; "deliveryPoints"?: number; "avgLoadFactor"?: number; "photo"?: any; "icon"?: any; }, options?: any) {
        return LpcApiFp.apiLpcByIdPut(params, options)(this.fetch, this.basePath);
    }
    /** 
     */
    apiLpcGet(options?: any) {
        return LpcApiFp.apiLpcGet(options)(this.fetch, this.basePath);
    }
    /** 
     * *Auth Required
     * @param name MaxLen:100
     * @param address1 MaxLen:100
     * @param city1 MaxLen:50
     * @param state1 MaxLen:2
     * @param zip1 MaxLen:50
     * @param address2 MaxLen:100
     * @param city2 MaxLen:50
     * @param state2 MaxLen:2
     * @param zip2 MaxLen:50
     * @param web MaxLen:100
     * @param phone MaxLen:10,Phone number
     * @param fax MaxLen:10,Phone number
     * @param totalElectricCustomers 
     * @param residentialCustomers 
     * @param cICustomersLessThan50kw 
     * @param cICustomers51To4999Kw 
     * @param cICustomersGreaterThan5000kw 
     * @param totalNaturalGasCustomers 
     * @param totalWaterCustomers 
     * @param totalWastewaterCustomers 
     * @param totalSystemAssets 
     * @param taxes 
     * @param milesOfLine 
     * @param customersPerMile 
     * @param avgResidentialUseInKwhPerMonth 
     * @param deliveryPoints 
     * @param avgLoadFactor 
     * @param photo 
     * @param icon 
     */
    apiLpcPost(params: {  "name"?: string; "address1"?: string; "city1"?: string; "state1"?: string; "zip1"?: string; "address2"?: string; "city2"?: string; "state2"?: string; "zip2"?: string; "web"?: string; "phone"?: string; "fax"?: string; "totalElectricCustomers"?: number; "residentialCustomers"?: number; "cICustomersLessThan50kw"?: number; "cICustomers51To4999Kw"?: number; "cICustomersGreaterThan5000kw"?: number; "totalNaturalGasCustomers"?: number; "totalWaterCustomers"?: number; "totalWastewaterCustomers"?: number; "totalSystemAssets"?: number; "taxes"?: number; "milesOfLine"?: number; "customersPerMile"?: number; "avgResidentialUseInKwhPerMonth"?: number; "deliveryPoints"?: number; "avgLoadFactor"?: number; "photo"?: any; "icon"?: any; }, options?: any) {
        return LpcApiFp.apiLpcPost(params, options)(this.fetch, this.basePath);
    }
};

/**
 * LpcApi - factory interface
 */
export const LpcApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * *Auth Required
         * @param id 
         */
        apiLpcByIdDelete(params: {  "id": string; }, options?: any) {
            return LpcApiFp.apiLpcByIdDelete(params, options)(fetch, basePath);
        },
        /** 
         * @param id 
         */
        apiLpcByIdGet(params: {  "id": string; }, options?: any) {
            return LpcApiFp.apiLpcByIdGet(params, options)(fetch, basePath);
        },
        /** 
         * @param id 
         * @param width 
         * @param height 
         */
        apiLpcByIdIconGet(params: {  "id": string; "width"?: number; "height"?: number; }, options?: any) {
            return LpcApiFp.apiLpcByIdIconGet(params, options)(fetch, basePath);
        },
        /** 
         * *Auth Required
         * @param id 
         * @param icon 
         */
        apiLpcByIdIconPost(params: {  "id": string; "icon"?: any; }, options?: any) {
            return LpcApiFp.apiLpcByIdIconPost(params, options)(fetch, basePath);
        },
        /** 
         * @param id 
         * @param width 
         * @param height 
         */
        apiLpcByIdPhotoGet(params: {  "id": string; "width"?: number; "height"?: number; }, options?: any) {
            return LpcApiFp.apiLpcByIdPhotoGet(params, options)(fetch, basePath);
        },
        /** 
         * *Auth Required
         * @param id 
         * @param photo 
         */
        apiLpcByIdPhotoPost(params: {  "id": string; "photo"?: any; }, options?: any) {
            return LpcApiFp.apiLpcByIdPhotoPost(params, options)(fetch, basePath);
        },
        /** 
         * *Auth Required
         * @param id 
         * @param name MaxLen:100
         * @param address1 MaxLen:100
         * @param city1 MaxLen:50
         * @param state1 MaxLen:2
         * @param zip1 MaxLen:50
         * @param address2 MaxLen:100
         * @param city2 MaxLen:50
         * @param state2 MaxLen:2
         * @param zip2 MaxLen:50
         * @param web MaxLen:100
         * @param phone MaxLen:10,Phone number
         * @param fax MaxLen:10,Phone number
         * @param totalElectricCustomers 
         * @param residentialCustomers 
         * @param cICustomersLessThan50kw 
         * @param cICustomers51To4999Kw 
         * @param cICustomersGreaterThan5000kw 
         * @param totalNaturalGasCustomers 
         * @param totalWaterCustomers 
         * @param totalWastewaterCustomers 
         * @param totalSystemAssets 
         * @param taxes 
         * @param milesOfLine 
         * @param customersPerMile 
         * @param avgResidentialUseInKwhPerMonth 
         * @param deliveryPoints 
         * @param avgLoadFactor 
         * @param photo 
         * @param icon 
         */
        apiLpcByIdPut(params: {  "id": string; "name"?: string; "address1"?: string; "city1"?: string; "state1"?: string; "zip1"?: string; "address2"?: string; "city2"?: string; "state2"?: string; "zip2"?: string; "web"?: string; "phone"?: string; "fax"?: string; "totalElectricCustomers"?: number; "residentialCustomers"?: number; "cICustomersLessThan50kw"?: number; "cICustomers51To4999Kw"?: number; "cICustomersGreaterThan5000kw"?: number; "totalNaturalGasCustomers"?: number; "totalWaterCustomers"?: number; "totalWastewaterCustomers"?: number; "totalSystemAssets"?: number; "taxes"?: number; "milesOfLine"?: number; "customersPerMile"?: number; "avgResidentialUseInKwhPerMonth"?: number; "deliveryPoints"?: number; "avgLoadFactor"?: number; "photo"?: any; "icon"?: any; }, options?: any) {
            return LpcApiFp.apiLpcByIdPut(params, options)(fetch, basePath);
        },
        /** 
         */
        apiLpcGet(options?: any) {
            return LpcApiFp.apiLpcGet(options)(fetch, basePath);
        },
        /** 
         * *Auth Required
         * @param name MaxLen:100
         * @param address1 MaxLen:100
         * @param city1 MaxLen:50
         * @param state1 MaxLen:2
         * @param zip1 MaxLen:50
         * @param address2 MaxLen:100
         * @param city2 MaxLen:50
         * @param state2 MaxLen:2
         * @param zip2 MaxLen:50
         * @param web MaxLen:100
         * @param phone MaxLen:10,Phone number
         * @param fax MaxLen:10,Phone number
         * @param totalElectricCustomers 
         * @param residentialCustomers 
         * @param cICustomersLessThan50kw 
         * @param cICustomers51To4999Kw 
         * @param cICustomersGreaterThan5000kw 
         * @param totalNaturalGasCustomers 
         * @param totalWaterCustomers 
         * @param totalWastewaterCustomers 
         * @param totalSystemAssets 
         * @param taxes 
         * @param milesOfLine 
         * @param customersPerMile 
         * @param avgResidentialUseInKwhPerMonth 
         * @param deliveryPoints 
         * @param avgLoadFactor 
         * @param photo 
         * @param icon 
         */
        apiLpcPost(params: {  "name"?: string; "address1"?: string; "city1"?: string; "state1"?: string; "zip1"?: string; "address2"?: string; "city2"?: string; "state2"?: string; "zip2"?: string; "web"?: string; "phone"?: string; "fax"?: string; "totalElectricCustomers"?: number; "residentialCustomers"?: number; "cICustomersLessThan50kw"?: number; "cICustomers51To4999Kw"?: number; "cICustomersGreaterThan5000kw"?: number; "totalNaturalGasCustomers"?: number; "totalWaterCustomers"?: number; "totalWastewaterCustomers"?: number; "totalSystemAssets"?: number; "taxes"?: number; "milesOfLine"?: number; "customersPerMile"?: number; "avgResidentialUseInKwhPerMonth"?: number; "deliveryPoints"?: number; "avgLoadFactor"?: number; "photo"?: any; "icon"?: any; }, options?: any) {
            return LpcApiFp.apiLpcPost(params, options)(fetch, basePath);
        },
    };
};


/**
 * PdfCategoriesApi - fetch parameter creator
 */
export const PdfCategoriesApiFetchParamCreator = {
    /** 
     * *Auth Required
     * @param id 
     */
    apiPdfCategoriesByIdDelete(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling apiPdfCategoriesByIdDelete");
        }
        const baseUrl = `/api/PdfCategories/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param id 
     */
    apiPdfCategoriesByIdGet(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling apiPdfCategoriesByIdGet");
        }
        const baseUrl = `/api/PdfCategories/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * *Auth Required
     * @param id 
     * @param label 
     */
    apiPdfCategoriesByIdPut(params: {  "id": string; "label"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling apiPdfCategoriesByIdPut");
        }
        const baseUrl = `/api/PdfCategories/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "Label": params["label"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param screen 
     */
    apiPdfCategoriesGet(params: {  "screen"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/api/PdfCategories`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "screen": params["screen"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * *Auth Required
     * @param label 
     */
    apiPdfCategoriesPost(params: {  "label"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/api/PdfCategories`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "Label": params["label"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PdfCategoriesApi - functional programming interface
 */
export const PdfCategoriesApiFp = {
    /** 
     * *Auth Required
     * @param id 
     */
    apiPdfCategoriesByIdDelete(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PdfCategoriesApiFetchParamCreator.apiPdfCategoriesByIdDelete(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param id 
     */
    apiPdfCategoriesByIdGet(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200PdfCategoriesUpsert> {
        const fetchArgs = PdfCategoriesApiFetchParamCreator.apiPdfCategoriesByIdGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * *Auth Required
     * @param id 
     * @param label 
     */
    apiPdfCategoriesByIdPut(params: { "id": string; "label"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200PdfCategoriesUpsert> {
        const fetchArgs = PdfCategoriesApiFetchParamCreator.apiPdfCategoriesByIdPut(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param screen 
     */
    apiPdfCategoriesGet(params: { "screen"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse200PdfCategoriesUpsert>> {
        const fetchArgs = PdfCategoriesApiFetchParamCreator.apiPdfCategoriesGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * *Auth Required
     * @param label 
     */
    apiPdfCategoriesPost(params: { "label"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200PdfCategoriesUpsert> {
        const fetchArgs = PdfCategoriesApiFetchParamCreator.apiPdfCategoriesPost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PdfCategoriesApi - object-oriented interface
 */
export class PdfCategoriesApi extends BaseAPI {
    /** 
     * *Auth Required
     * @param id 
     */
    apiPdfCategoriesByIdDelete(params: {  "id": string; }, options?: any) {
        return PdfCategoriesApiFp.apiPdfCategoriesByIdDelete(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param id 
     */
    apiPdfCategoriesByIdGet(params: {  "id": string; }, options?: any) {
        return PdfCategoriesApiFp.apiPdfCategoriesByIdGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * *Auth Required
     * @param id 
     * @param label 
     */
    apiPdfCategoriesByIdPut(params: {  "id": string; "label"?: string; }, options?: any) {
        return PdfCategoriesApiFp.apiPdfCategoriesByIdPut(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param screen 
     */
    apiPdfCategoriesGet(params: {  "screen"?: string; }, options?: any) {
        return PdfCategoriesApiFp.apiPdfCategoriesGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * *Auth Required
     * @param label 
     */
    apiPdfCategoriesPost(params: {  "label"?: string; }, options?: any) {
        return PdfCategoriesApiFp.apiPdfCategoriesPost(params, options)(this.fetch, this.basePath);
    }
};

/**
 * PdfCategoriesApi - factory interface
 */
export const PdfCategoriesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * *Auth Required
         * @param id 
         */
        apiPdfCategoriesByIdDelete(params: {  "id": string; }, options?: any) {
            return PdfCategoriesApiFp.apiPdfCategoriesByIdDelete(params, options)(fetch, basePath);
        },
        /** 
         * @param id 
         */
        apiPdfCategoriesByIdGet(params: {  "id": string; }, options?: any) {
            return PdfCategoriesApiFp.apiPdfCategoriesByIdGet(params, options)(fetch, basePath);
        },
        /** 
         * *Auth Required
         * @param id 
         * @param label 
         */
        apiPdfCategoriesByIdPut(params: {  "id": string; "label"?: string; }, options?: any) {
            return PdfCategoriesApiFp.apiPdfCategoriesByIdPut(params, options)(fetch, basePath);
        },
        /** 
         * @param screen 
         */
        apiPdfCategoriesGet(params: {  "screen"?: string; }, options?: any) {
            return PdfCategoriesApiFp.apiPdfCategoriesGet(params, options)(fetch, basePath);
        },
        /** 
         * *Auth Required
         * @param label 
         */
        apiPdfCategoriesPost(params: {  "label"?: string; }, options?: any) {
            return PdfCategoriesApiFp.apiPdfCategoriesPost(params, options)(fetch, basePath);
        },
    };
};


/**
 * PdfScreensApi - fetch parameter creator
 */
export const PdfScreensApiFetchParamCreator = {
    /** 
     * @param screen 
     * @param categoryId 
     */
    apiPdfScreensByScreenCategoriesByCategoryIdPdfsGet(params: {  "screen": string; "categoryId": string; }, options?: any): FetchArgs {
        // verify required parameter "screen" is set
        if (params["screen"] == null) {
            throw new Error("Missing required parameter screen when calling apiPdfScreensByScreenCategoriesByCategoryIdPdfsGet");
        }
        // verify required parameter "categoryId" is set
        if (params["categoryId"] == null) {
            throw new Error("Missing required parameter categoryId when calling apiPdfScreensByScreenCategoriesByCategoryIdPdfsGet");
        }
        const baseUrl = `/api/PdfScreens/{screen}/Categories/{categoryId}/Pdfs`
            .replace(`{${"screen"}}`, `${ params["screen"] }`)
            .replace(`{${"categoryId"}}`, `${ params["categoryId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param screen 
     */
    apiPdfScreensByScreenCategoriesGet(params: {  "screen": string; }, options?: any): FetchArgs {
        // verify required parameter "screen" is set
        if (params["screen"] == null) {
            throw new Error("Missing required parameter screen when calling apiPdfScreensByScreenCategoriesGet");
        }
        const baseUrl = `/api/PdfScreens/{screen}/Categories`
            .replace(`{${"screen"}}`, `${ params["screen"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param screen 
     */
    apiPdfScreensByScreenPdfsGet(params: {  "screen": string; }, options?: any): FetchArgs {
        // verify required parameter "screen" is set
        if (params["screen"] == null) {
            throw new Error("Missing required parameter screen when calling apiPdfScreensByScreenPdfsGet");
        }
        const baseUrl = `/api/PdfScreens/{screen}/Pdfs`
            .replace(`{${"screen"}}`, `${ params["screen"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     */
    apiPdfScreensGet(options?: any): FetchArgs {
        const baseUrl = `/api/PdfScreens`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PdfScreensApi - functional programming interface
 */
export const PdfScreensApiFp = {
    /** 
     * @param screen 
     * @param categoryId 
     */
    apiPdfScreensByScreenCategoriesByCategoryIdPdfsGet(params: { "screen": string; "categoryId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse200PdfsUpsert>> {
        const fetchArgs = PdfScreensApiFetchParamCreator.apiPdfScreensByScreenCategoriesByCategoryIdPdfsGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param screen 
     */
    apiPdfScreensByScreenCategoriesGet(params: { "screen": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse200PdfCategoriesUpsert>> {
        const fetchArgs = PdfScreensApiFetchParamCreator.apiPdfScreensByScreenCategoriesGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param screen 
     */
    apiPdfScreensByScreenPdfsGet(params: { "screen": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse200PdfsUpsert>> {
        const fetchArgs = PdfScreensApiFetchParamCreator.apiPdfScreensByScreenPdfsGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     */
    apiPdfScreensGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
        const fetchArgs = PdfScreensApiFetchParamCreator.apiPdfScreensGet(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PdfScreensApi - object-oriented interface
 */
export class PdfScreensApi extends BaseAPI {
    /** 
     * @param screen 
     * @param categoryId 
     */
    apiPdfScreensByScreenCategoriesByCategoryIdPdfsGet(params: {  "screen": string; "categoryId": string; }, options?: any) {
        return PdfScreensApiFp.apiPdfScreensByScreenCategoriesByCategoryIdPdfsGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param screen 
     */
    apiPdfScreensByScreenCategoriesGet(params: {  "screen": string; }, options?: any) {
        return PdfScreensApiFp.apiPdfScreensByScreenCategoriesGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param screen 
     */
    apiPdfScreensByScreenPdfsGet(params: {  "screen": string; }, options?: any) {
        return PdfScreensApiFp.apiPdfScreensByScreenPdfsGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     */
    apiPdfScreensGet(options?: any) {
        return PdfScreensApiFp.apiPdfScreensGet(options)(this.fetch, this.basePath);
    }
};

/**
 * PdfScreensApi - factory interface
 */
export const PdfScreensApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param screen 
         * @param categoryId 
         */
        apiPdfScreensByScreenCategoriesByCategoryIdPdfsGet(params: {  "screen": string; "categoryId": string; }, options?: any) {
            return PdfScreensApiFp.apiPdfScreensByScreenCategoriesByCategoryIdPdfsGet(params, options)(fetch, basePath);
        },
        /** 
         * @param screen 
         */
        apiPdfScreensByScreenCategoriesGet(params: {  "screen": string; }, options?: any) {
            return PdfScreensApiFp.apiPdfScreensByScreenCategoriesGet(params, options)(fetch, basePath);
        },
        /** 
         * @param screen 
         */
        apiPdfScreensByScreenPdfsGet(params: {  "screen": string; }, options?: any) {
            return PdfScreensApiFp.apiPdfScreensByScreenPdfsGet(params, options)(fetch, basePath);
        },
        /** 
         */
        apiPdfScreensGet(options?: any) {
            return PdfScreensApiFp.apiPdfScreensGet(options)(fetch, basePath);
        },
    };
};


/**
 * PdfsApi - fetch parameter creator
 */
export const PdfsApiFetchParamCreator = {
    /** 
     * *Auth Required
     * @param id 
     */
    apiPdfsByIdDelete(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling apiPdfsByIdDelete");
        }
        const baseUrl = `/api/Pdfs/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param id 
     */
    apiPdfsByIdGet(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling apiPdfsByIdGet");
        }
        const baseUrl = `/api/Pdfs/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * *Auth Required
     * @param id 
     * @param screen 
     * @param categoryId 
     * @param label 
     */
    apiPdfsByIdPut(params: {  "id": string; "screen"?: string; "categoryId"?: string; "label"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling apiPdfsByIdPut");
        }
        const baseUrl = `/api/Pdfs/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "Screen": params["screen"],
            "CategoryId": params["categoryId"],
            "Label": params["label"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param pdfId 
     */
    apiPdfsByPdfIdDataGet(params: {  "pdfId": string; }, options?: any): FetchArgs {
        // verify required parameter "pdfId" is set
        if (params["pdfId"] == null) {
            throw new Error("Missing required parameter pdfId when calling apiPdfsByPdfIdDataGet");
        }
        const baseUrl = `/api/Pdfs/{pdfId}/Data`
            .replace(`{${"pdfId"}}`, `${ params["pdfId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * *Auth Required
     * @param pdfId 
     * @param uploadedFile 
     */
    apiPdfsByPdfIdDataPost(params: {  "pdfId": string; "uploadedFile"?: any; }, options?: any): FetchArgs {
        // verify required parameter "pdfId" is set
        if (params["pdfId"] == null) {
            throw new Error("Missing required parameter pdfId when calling apiPdfsByPdfIdDataPost");
        }
        const baseUrl = `/api/Pdfs/{pdfId}/Data`
            .replace(`{${"pdfId"}}`, `${ params["pdfId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "uploadedFile": params["uploadedFile"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param screen 
     */
    apiPdfsGet(params: {  "screen"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/api/Pdfs`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "screen": params["screen"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * *Auth Required
     * @param screen 
     * @param categoryId 
     * @param label 
     * @param uploadedFile 
     */
    apiPdfsPost(params: {  "screen"?: string; "categoryId"?: string; "label"?: string; "uploadedFile"?: any; }, options?: any): FetchArgs {
        const baseUrl = `/api/Pdfs`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "Screen": params["screen"],
            "CategoryId": params["categoryId"],
            "Label": params["label"],
            "uploadedFile": params["uploadedFile"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PdfsApi - functional programming interface
 */
export const PdfsApiFp = {
    /** 
     * *Auth Required
     * @param id 
     */
    apiPdfsByIdDelete(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PdfsApiFetchParamCreator.apiPdfsByIdDelete(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param id 
     */
    apiPdfsByIdGet(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200PdfsUpsert> {
        const fetchArgs = PdfsApiFetchParamCreator.apiPdfsByIdGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * *Auth Required
     * @param id 
     * @param screen 
     * @param categoryId 
     * @param label 
     */
    apiPdfsByIdPut(params: { "id": string; "screen"?: string; "categoryId"?: string; "label"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200PdfsUpsert> {
        const fetchArgs = PdfsApiFetchParamCreator.apiPdfsByIdPut(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param pdfId 
     */
    apiPdfsByPdfIdDataGet(params: { "pdfId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PdfsApiFetchParamCreator.apiPdfsByPdfIdDataGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * *Auth Required
     * @param pdfId 
     * @param uploadedFile 
     */
    apiPdfsByPdfIdDataPost(params: { "pdfId": string; "uploadedFile"?: any;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PdfsApiFetchParamCreator.apiPdfsByPdfIdDataPost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param screen 
     */
    apiPdfsGet(params: { "screen"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse200PdfsUpsert>> {
        const fetchArgs = PdfsApiFetchParamCreator.apiPdfsGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * *Auth Required
     * @param screen 
     * @param categoryId 
     * @param label 
     * @param uploadedFile 
     */
    apiPdfsPost(params: { "screen"?: string; "categoryId"?: string; "label"?: string; "uploadedFile"?: any;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200PdfsUpsert> {
        const fetchArgs = PdfsApiFetchParamCreator.apiPdfsPost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PdfsApi - object-oriented interface
 */
export class PdfsApi extends BaseAPI {
    /** 
     * *Auth Required
     * @param id 
     */
    apiPdfsByIdDelete(params: {  "id": string; }, options?: any) {
        return PdfsApiFp.apiPdfsByIdDelete(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param id 
     */
    apiPdfsByIdGet(params: {  "id": string; }, options?: any) {
        return PdfsApiFp.apiPdfsByIdGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * *Auth Required
     * @param id 
     * @param screen 
     * @param categoryId 
     * @param label 
     */
    apiPdfsByIdPut(params: {  "id": string; "screen"?: string; "categoryId"?: string; "label"?: string; }, options?: any) {
        return PdfsApiFp.apiPdfsByIdPut(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param pdfId 
     */
    apiPdfsByPdfIdDataGet(params: {  "pdfId": string; }, options?: any) {
        return PdfsApiFp.apiPdfsByPdfIdDataGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * *Auth Required
     * @param pdfId 
     * @param uploadedFile 
     */
    apiPdfsByPdfIdDataPost(params: {  "pdfId": string; "uploadedFile"?: any; }, options?: any) {
        return PdfsApiFp.apiPdfsByPdfIdDataPost(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param screen 
     */
    apiPdfsGet(params: {  "screen"?: string; }, options?: any) {
        return PdfsApiFp.apiPdfsGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * *Auth Required
     * @param screen 
     * @param categoryId 
     * @param label 
     * @param uploadedFile 
     */
    apiPdfsPost(params: {  "screen"?: string; "categoryId"?: string; "label"?: string; "uploadedFile"?: any; }, options?: any) {
        return PdfsApiFp.apiPdfsPost(params, options)(this.fetch, this.basePath);
    }
};

/**
 * PdfsApi - factory interface
 */
export const PdfsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * *Auth Required
         * @param id 
         */
        apiPdfsByIdDelete(params: {  "id": string; }, options?: any) {
            return PdfsApiFp.apiPdfsByIdDelete(params, options)(fetch, basePath);
        },
        /** 
         * @param id 
         */
        apiPdfsByIdGet(params: {  "id": string; }, options?: any) {
            return PdfsApiFp.apiPdfsByIdGet(params, options)(fetch, basePath);
        },
        /** 
         * *Auth Required
         * @param id 
         * @param screen 
         * @param categoryId 
         * @param label 
         */
        apiPdfsByIdPut(params: {  "id": string; "screen"?: string; "categoryId"?: string; "label"?: string; }, options?: any) {
            return PdfsApiFp.apiPdfsByIdPut(params, options)(fetch, basePath);
        },
        /** 
         * @param pdfId 
         */
        apiPdfsByPdfIdDataGet(params: {  "pdfId": string; }, options?: any) {
            return PdfsApiFp.apiPdfsByPdfIdDataGet(params, options)(fetch, basePath);
        },
        /** 
         * *Auth Required
         * @param pdfId 
         * @param uploadedFile 
         */
        apiPdfsByPdfIdDataPost(params: {  "pdfId": string; "uploadedFile"?: any; }, options?: any) {
            return PdfsApiFp.apiPdfsByPdfIdDataPost(params, options)(fetch, basePath);
        },
        /** 
         * @param screen 
         */
        apiPdfsGet(params: {  "screen"?: string; }, options?: any) {
            return PdfsApiFp.apiPdfsGet(params, options)(fetch, basePath);
        },
        /** 
         * *Auth Required
         * @param screen 
         * @param categoryId 
         * @param label 
         * @param uploadedFile 
         */
        apiPdfsPost(params: {  "screen"?: string; "categoryId"?: string; "label"?: string; "uploadedFile"?: any; }, options?: any) {
            return PdfsApiFp.apiPdfsPost(params, options)(fetch, basePath);
        },
    };
};

